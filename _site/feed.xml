<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2025-09-16T08:43:17+02:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Enrique Goberna</title><subtitle>Personal site + blog about building my portfolio</subtitle><entry><title type="html">Order Tracking — First Steps into My Portfolio</title><link href="http://0.0.0.0:4000/blog/order-tracking-first-steps/" rel="alternate" type="text/html" title="Order Tracking — First Steps into My Portfolio" /><published>2025-09-16T00:00:00+02:00</published><updated>2025-09-16T00:00:00+02:00</updated><id>http://0.0.0.0:4000/blog/order-tracking-first-steps</id><content type="html" xml:base="http://0.0.0.0:4000/blog/order-tracking-first-steps/"><![CDATA[<p>The first concrete project in my portfolio is an <strong>Order Tracking</strong> service. At its core, it’s simple: an API to create orders, update their status, and check where they are in the delivery process. But even a small project like this can already show the kind of engineering mindset I want this blog to reflect.</p>

<h3 id="building-the-basics">Building the Basics</h3>
<p>Right now, the service is built with <strong>Java + Spring Boot</strong>, using <strong>PostgreSQL</strong> for persistence. The initial version is intentionally minimal:</p>
<ul>
  <li>Endpoints for creating orders and updating statuses.</li>
  <li>An in-memory + database persistence layer.</li>
  <li>H2 for quick local testing, Postgres for real runs.</li>
</ul>

<p>The goal at this stage isn’t complexity — it’s a clean foundation to build on. You can explore the code here: <a href="https://github.com/egobb/order-tracking">GitHub repo</a>.</p>

<h3 id="choosing-the-stack">Choosing the Stack</h3>
<p>Why this combination of technologies?</p>
<ul>
  <li><strong>Spring Boot</strong>: widely adopted, strong ecosystem, and perfect for microservice-style projects.</li>
  <li><strong>PostgreSQL</strong>: relational, reliable, and great at enforcing order state constraints.</li>
  <li><strong>OpenAPI</strong>: built-in documentation so that anyone can test the service easily.</li>
</ul>

<p>Of course, I could have gone with MongoDB or even an event-sourced model from the start. But the decision was to begin with something straightforward and solid, then evolve later into more advanced patterns like Kafka events and CQRS.</p>

<h3 id="lessons-from-the-first-iteration">Lessons from the First Iteration</h3>
<p>Even at this early stage, there were small takeaways:</p>
<ul>
  <li><strong>Order states are not trivial</strong>: defining valid transitions (<code class="language-plaintext highlighter-rouge">PLACED → IN_TRANSIT → DELIVERED</code>) prevents messy bugs later.</li>
  <li><strong>Fast local development</strong> matters: H2 in memory for tests keeps the feedback loop short.</li>
  <li><strong>APIs should be clear</strong> from the beginning: consistent request/response models save headaches in the future.</li>
</ul>

<p>At one point I had too much logic inside the controllers, and quickly realized it needed to move into services to keep things maintainable. A good reminder that structure matters from day one.</p>

<h3 id="looking-at-the-bigger-picture">Looking at the Bigger Picture</h3>
<p>This project might look small, but it represents something important for me: instead of just working on large-scale systems at my day job, I’m building <strong>my own projects</strong> that mirror real-world scenarios. Order tracking is something I’ve worked with professionally before, and here I can both <strong>simplify it</strong> for learning and <strong>expand it</strong> to showcase architecture skills.</p>

<h3 id="next-steps">Next Steps</h3>
<p>The service will continue to grow over the coming months. The plan is simple:</p>
<ul>
  <li><strong>Security</strong>: add OAuth2/JWT authentication with Keycloak.</li>
  <li><strong>Resilience</strong>: introduce an API Gateway with rate limiting, retries, and circuit breakers.</li>
  <li><strong>Observability</strong>: integrate metrics, structured logging, and dashboards.</li>
  <li><strong>Frontend</strong>: build a small React SPA to visualize orders and notifications.</li>
  <li><strong>Advanced patterns</strong>: explore CQRS, event sourcing, and caching.</li>
  <li><strong>Deployment polish</strong>: Docker Compose for all services and Infrastructure as Code for cloud readiness.</li>
</ul>

<hr />

<p>This is only the beginning. The Order Tracking service starts small, but it will evolve into a complete case study of how to design, grow, and polish a system step by step — the exact kind of journey I want to capture in this blog.</p>]]></content><author><name></name></author><category term="portfolio" /><category term="projects" /><category term="order-tracking" /><category term="java" /><category term="spring-boot" /><category term="postgres" /><category term="portfolio" /><summary type="html"><![CDATA[The first concrete project in my portfolio is an Order Tracking service. At its core, it’s simple: an API to create orders, update their status, and check where they are in the delivery process. But even a small project like this can already show the kind of engineering mindset I want this blog to reflect.]]></summary></entry><entry><title type="html">Welcome to the Blog: Building My Portfolio</title><link href="http://0.0.0.0:4000/blog/welcome-blog/" rel="alternate" type="text/html" title="Welcome to the Blog: Building My Portfolio" /><published>2025-09-16T00:00:00+02:00</published><updated>2025-09-16T00:00:00+02:00</updated><id>http://0.0.0.0:4000/blog/welcome-blog</id><content type="html" xml:base="http://0.0.0.0:4000/blog/welcome-blog/"><![CDATA[<p>As a software engineer with more than nine years of experience — I’ve spent most of my career building scalable, high-volume data systems for e-commerce. Over time, I’ve realized something very clear: no matter how much you grow in the industry, <strong>having a personal portfolio is no longer optional</strong>. It’s a must-have.</p>

<p>This blog is my space to document that journey. Every step I take to design, improve, and polish my portfolio will be written down here — not only as a way to keep myself accountable, but also to share ideas and approaches that might help other engineers in a similar situation. Think of it as a public logbook of progress.</p>

<h3 id="why-a-portfolio">Why a Portfolio?</h3>
<p>A portfolio is more than just a résumé with code. It’s a way to <strong>showcase skills, decisions, and technical judgment in a tangible way</strong>. Recruiters and companies don’t just want to read that you’ve worked with Java, Kafka, or distributed systems — they want to see how you <em>apply</em> those technologies. A portfolio is the bridge between words and proof.</p>

<h3 id="what-to-expect-here">What to Expect Here</h3>
<p>The posts in this blog will cover:</p>
<ul>
  <li><strong>Technical breakdowns</strong> of the features I add to my portfolio projects.</li>
  <li><strong>Design decisions</strong>: why I chose one approach over another.</li>
  <li><strong>Learnings along the way</strong>, including mistakes (which are often the most valuable lessons).</li>
  <li>Reflections on my career so far and how this portfolio ties into where I want to go next.</li>
</ul>

<h3 id="a-bit-about-me">A Bit About Me</h3>
<p>I’m currently working as a Senior Software Engineer, specialized in backend development, distributed systems, and large-scale data processing. My experience spans from legacy systems to microservices architectures, with a focus on building reliable, high-volume solutions. I enjoy working at the intersection of <strong>technical design and functional analysis</strong>, helping teams bridge business needs with scalable technical implementations.</p>

<p>Outside of the day-to-day coding, I see this blog as a creative outlet: a way to keep track of my own growth while sharing a story that’s bigger than just commits and pull requests.</p>

<hr />

<p>This is just the beginning. Over the next posts, I’ll be unpacking how I’m structuring my portfolio, what tools I’m choosing, and the reasoning behind each decision. If you’re also working on your own portfolio — or thinking of starting — I hope you’ll find some inspiration here.</p>]]></content><author><name></name></author><category term="portfolio" /><category term="personal" /><category term="career" /><category term="software-engineering" /><category term="portfolio" /><category term="career-growth" /><category term="blogging" /><summary type="html"><![CDATA[As a software engineer with more than nine years of experience — I’ve spent most of my career building scalable, high-volume data systems for e-commerce. Over time, I’ve realized something very clear: no matter how much you grow in the industry, having a personal portfolio is no longer optional. It’s a must-have.]]></summary></entry></feed>